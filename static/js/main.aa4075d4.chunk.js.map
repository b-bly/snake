{"version":3,"sources":["Components/Message.js","helpers/constants.js","Game/square.js","Game/board.js","Game/snake-piece.js","Game/fruit.js","Game/relative-square.js","helpers/utility.js","helpers/style.js","Containers/game.js","App.js","serviceWorker.js","index.js"],"names":["modalFixed","position","zIndex","left","top","width","height","backgroundColor","modalContainer","display","alignItems","justifyContent","modalContent","flexFlow","textAlign","border","borderRadius","boxShadow","color","padding","maxWidth","fontSize","Message","props","style","message","playAgainButton","className","onClick","playAgain","CELLWIDTH","parseInt","WINDOWWIDTH","CELLHEIGHT","WINDOWHEIGHT","TOTAL_CELL_HEIGHT","BORDERWIDTH","TOTAL_CELL_WIDTH","X_VALUES_INSIDE","Array","fill","map","el","i","arr","Y_VALUES_INSIDE","INDICES100","_","BLACK","GREEN","UP","RIGHT","OPPOSITE_DIRECTIONS","DOWN","LEFT","Square","Board","board","j","key","toString","constants","SnakePiece","topPixels","Math","floor","leftPixels","console","log","Fruit","RelativeSquare","getDefaultState","playerState","direction","bodyIndex","turning","fruit","timeStamp","playerSpeed","paused","score","snakeLength","fruitEatenThisLevel","fruitValue","flexDirection","flex","marginLeft","margin","minWidth","row","scoreRow","marginTop","scoreText","fruitText","Game","start","playerInterval","setInterval","updatePlayerPosition","timeout","random","fruitTimeout","setTimeout","placeFruit","newFruit","checkOccupiedSquares","Date","UTC","setState","state","length","occupiedSquares","occupiedTop","occupiedLeft","piece","currentDirection","threshold","turningDirection","overshotDistance","movePlayer","shift","bodyPiece","checkForFruit","advanceLevel","playerDirection","endGame","nextPlayerState","unshift","pause","showMessage","clearMessage","window","clearInterval","clearTimeout","updatedFruitEatenThisLevel","updatedFruit","filter","fruitPiece","playerTop","playerLeft","fruitTop","fruitLeft","handlePlayerMovement","newDirection","turnObjectInHeadBool","updatedPlayerState","pop","getTurnThreshold","push","playerPosition","handleKeyDown","e","keyCode","this","onkeydown","snake","bind","Component","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.aa4075d4.chunk.js","sourcesContent":["import React from 'react'\n// CSS\nimport './Message.css'\n// Style\nconst modalFixed = {\n  position: 'fixed',\n\n  zIndex: '10',\n  left: '0',\n  top: '0',\n  width: '100%',\n  height: '100vh',\n\n  backgroundColor: 'rgba(0, 0, 0, 0.4)'\n}\n\nconst modalContainer = {\n  position: 'absolute',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n\n  height: '100%',\n  width: '100%'\n}\n\nconst modalContent = {\n  zIndex: '1',\n  display: 'flex',\n  flexFlow: 'column nowrap',\n  textAlign: 'center',\n\n  border: '7px solid #448EE4',\n  borderRadius: '20px', // 20 padding + 47 button height\n  boxShadow: 'inset 0 -80px black, 0px 0px 20px rgb(112, 112, 112)',\n  backgroundColor: 'black',\n  color: 'white',\n\n  padding: '20px', // max-width: 750px;\n  maxWidth: '750px',\n  fontSize: '30px'\n}\n// Component\n\nconst Message = (props) =>\n  <div style={modalFixed}>\n    <div style={modalContainer}>\n      <div style={modalContent}>\n        <div>\n          {props.message}\n        </div>\n        <div>\n          {props.playAgainButton === true && (\n            <button className=\"btn btn-success message-margin\"\n              onClick={props.playAgain}\n            >Play Again</button>\n          )}\n        </div>\n      </div>\n    </div>\n  </div>\n\nexport default Message","\nexport const FPS = 8\nexport const INTERVAL = 1000 / FPS // how often game is updated in ms\nexport const WINDOWWIDTH = 640\nexport const WINDOWHEIGHT = 640 // pixels\nexport const CELLSIZE = 20  // number squares on board.  Should be called board size?\nexport const CELLSIZE100 = CELLSIZE * 100;\nexport const BORDERWIDTH = 2;\nexport const CELLWIDTH = parseInt(WINDOWWIDTH / CELLSIZE); // width in pixels of board cell\nexport const CELLHEIGHT = parseInt(WINDOWHEIGHT / CELLSIZE);\nexport const TOTAL_CELL_HEIGHT = CELLHEIGHT + BORDERWIDTH * 2;\nexport const TOTAL_CELL_WIDTH = CELLWIDTH + BORDERWIDTH * 2;\nexport const Y_OFFSET = 0; // 100 // distance from top of window to top of board\nexport const X_OFFSET = 0;\nexport const X_VALUES_INSIDE = Array(CELLSIZE).fill('').map((el, i, arr) => {\n  return i * CELLWIDTH + X_OFFSET + BORDERWIDTH;\n});\nexport const Y_VALUES_INSIDE = Array(CELLSIZE).fill('').map((el, i, arr) => {\n  return i * CELLHEIGHT + Y_OFFSET + BORDERWIDTH;\n});\nexport const X_VALUES_OUTSIDE = Array(CELLSIZE).fill('').map((el, i, arr) => {\n  return i * CELLWIDTH + X_OFFSET;\n});\nexport const Y_VALUES_OUTSIDE = Array(CELLSIZE).fill('').map((el, i, arr) => {\n  return i * CELLHEIGHT + Y_OFFSET;\n});\nexport const INDICES = Array(CELLSIZE).fill('').map((_, i) => {\n  return i\n})\nexport const INDICES100 = Array(CELLSIZE).fill('').map((_, i) => {\n  return i*100\n})\n\nexport const INFO_PANEL_MARGIN = CELLSIZE * CELLWIDTH + X_OFFSET + 'px'\n\nexport const WHITE = 'rgb(255, 255, 255)'\n\nexport const BLACK = 'rgb(  0,   0,   0)'\n\nexport const RED = 'rgb(255,   0,   0)'\n\nexport const GREEN = 'rgb(  0, 255,   0)'\n\nexport const DARKGREEN = 'rgb(  0, 155,   0)'\n\nexport const DARKGRAY = 'rgb( 40,  40,  40)'\n\nexport const BGCOLOR = BLACK\n\nexport const UP = 'UP'\n\nexport const DOWN = 'DOWN'\n\nexport const LEFT = 'LEFT'\n\nexport const RIGHT = 'RIGHT'\n\nexport const HEAD = 0\n\nexport const OPPOSITE_DIRECTIONS = {\n  UP: DOWN,\n  DOWN: UP,\n  LEFT: RIGHT,\n  RIGHT: LEFT,\n}\n\nexport const NEXT_LEVEL_THRESHOLD = 2","import React from 'react'\nimport { BORDERWIDTH, CELLHEIGHT, CELLWIDTH } from '../helpers/constants'\n\nconst Square = (props) => {\n\n  const style = {\n    backgroundColor: props.backgroundColor,\n    border: props.border ? BORDERWIDTH + 'px solid gray' : '',\n    width: CELLWIDTH - BORDERWIDTH*2,\n    height: CELLHEIGHT -BORDERWIDTH*2,\n    zIndex: props.zIndex,\n    position: 'absolute',\n    top: props.top,\n    left: props.left,\n  }\n  return (\n    <div\n      style={style}>\n    </div>\n  )\n}\n\nexport default Square","import React from 'react'\nimport * as constants from '../helpers/constants'\nimport Square from './square'\n\nconst Board = () => {\n  const board = Array(constants.CELLSIZE).fill('').map((el, i, arr) => {\n    return (\n      // <div key={i.toString()} style={{\n      //   display: 'inline-block',\n      //   position: 'relative'\n      // }}>\n      arr.map((el, j) => {\n        return (\n          <Square key={j.toString()}\n            // placeholder until props pass the correct color\n            backgroundColor={constants.BLACK}\n            top={i * constants.CELLHEIGHT + constants.Y_OFFSET}\n            left={j * constants.CELLWIDTH + constants.X_OFFSET}\n            zIndex='0'\n            border={false}\n          />\n        )\n      })\n      // </div>\n    )\n  });\n\n  return (\n    <div>\n        {board}\n    </div>\n  )\n}\n\nexport default Board","import React, { Fragment } from 'react'\nimport { RED, X_VALUES_INSIDE, Y_VALUES_INSIDE, Y_OFFSET, TOTAL_CELL_HEIGHT, TOTAL_CELL_WIDTH, BORDERWIDTH} from '../helpers/constants'\nimport Square from './square'\n\nconst SnakePiece = (props) => {\n    const { top, left } = props\n    const topPixels = Y_VALUES_INSIDE[Math.floor(top/100)] + ((TOTAL_CELL_HEIGHT) * (top%100)/100)\n    const leftPixels = X_VALUES_INSIDE[Math.floor(left/100)] + ((TOTAL_CELL_WIDTH) * (left%100)/100)\n  \n    if (topPixels < Y_OFFSET) console.log('$$$ less than y offset @@@');\n    return (\n      <Fragment>\n        <Square\n          backgroundColor={RED}\n          zIndex={'2'}\n          top={topPixels}\n          left={leftPixels}\n          border={false}\n        />\n      </Fragment>\n    )\n}\n\nexport default SnakePiece","import React, { Fragment } from 'react'\nimport { GREEN, X_VALUES_INSIDE, Y_VALUES_INSIDE, Y_OFFSET, TOTAL_CELL_HEIGHT, TOTAL_CELL_WIDTH, BORDERWIDTH} from '../helpers/constants'\nimport Square from './square'\n\nconst Fruit = (props) => {\n    const { top, left } = props\n    const topPixels = Y_VALUES_INSIDE[Math.floor(top/100)] + ((TOTAL_CELL_HEIGHT) * (top%100)/100)\n    const leftPixels = X_VALUES_INSIDE[Math.floor(left/100)] + ((TOTAL_CELL_WIDTH) * (left%100)/100)\n  \n    // if (leftPixels < Y_OFFSET) console.log('$$$ less than y offset @@@');\n    return (\n      <Fragment>\n        <Square\n          backgroundColor={GREEN}\n          zIndex={'1'}\n          top={topPixels}\n          left={leftPixels}\n          border={false}\n        />\n      </Fragment>\n    )\n}\n\nexport default Fruit","import React from 'react'\nimport { BORDERWIDTH, CELLHEIGHT, CELLWIDTH } from '../helpers/constants'\n\nconst RelativeSquare = (props) => {\n\n  const style = {\n    backgroundColor: props.backgroundColor,\n    border: props.border ? BORDERWIDTH + 'px solid gray' : '',\n    width: CELLWIDTH - BORDERWIDTH*2,\n    height: CELLHEIGHT -BORDERWIDTH*2,\n  }\n  return (\n    <div\n      style={style}>\n    </div>\n  )\n}\n\nexport default RelativeSquare","\nimport * as constants from './constants'\nexport const getDefaultState = () => {\n  return {\n    playerState: [\n      { // first item is the head\n        top: constants.INDICES100[0],\n        left: constants.INDICES100[5],\n        direction: constants.RIGHT,\n        bodyIndex: 0,\n        turning: [] // direction, threshold\n      },\n      // 2nd body piece\n      {\n\n        top: constants.INDICES100[0],\n        left: constants.INDICES100[4],\n        direction: constants.RIGHT,\n        bodyIndex: 1,\n        turning: []\n      },\n      // 3rd body piece for testing\n      // {\n      //   top: constants.INDICES100[0],\n      //   left: constants.INDICES100[3],\n      //   direction: constants.RIGHT,\n      //   bodyIndex: 2,\n      //   turning: []\n      // }\n    ],\n    fruit: [\n      {\n      top: constants.INDICES100[1],\n      left: constants.INDICES100[1],\n      timeStamp: 0,\n    }\n  ],\n    playerSpeed: 30,\n    paused: false,\n    score: 0,\n    snakeLength: 2,\n    fruitEatenThisLevel: 1,\n    fruitValue: 1,\n    message: false,\n    playAgainButton: false,\n  }\n}","import * as constants from './constants'\n\nexport const score = {\n  display: 'flex',\n  flexDirection: 'column',\n  alignItems: 'flex-start',\n  flex: '0 1 auto',\n  marginLeft: '10px',\n  padding: '5px',\n  margin: 'auto 5px',\n  border: '4px solid white',\n  borderRadius: '4px',\n  minWidth: '135px'\n}\n\n\nexport const row = {\n  display: 'flex',\n  justifyContent: 'center',\n  flexFlow: 'row reverse-wrap',\n  width: '100%',\n}\n\nexport const scoreRow = {\n  ...row,\n  alignItems: 'center'\n}\n\nexport const board = {\n  marginTop: '50px',\n  position: 'relative',\n  width: constants.WINDOWWIDTH + 'px',\n  height: constants.WINDOWHEIGHT + 'px',\n  border: '2px solid gray'\n}\n\nexport const scoreText = {\n  color: \"white\",\n  fontSize: \"20px\",\n  margin: '5px 0'\n}\n\nexport const fruitText = {\n  ...scoreText,\n  marginLeft: '10px'\n}","import React, { Component } from 'react';\n// components\nimport Message from '../Components/Message'\nimport Board from '../Game/board'\nimport SnakePiece from '../Game/snake-piece'\nimport Fruit from '../Game/fruit'\nimport RelativeSquare from '../Game/relative-square'\n// import SnakeBody from '../Game/snake-body'\n// import Square from '../Game/square'\nimport * as constants from '../helpers/constants'\nimport { getDefaultState } from '../helpers/utility'\nimport { score, row, scoreRow, board, scoreText, fruitText } from '../helpers/style'\n\nexport default class Game extends Component {\n  constructor() {\n    super()\n    this.state = getDefaultState();\n  }\n\n  componentDidMount() {\n    this.start()\n    window.onkeydown = this.handleKeyDown\n  }\n\n  componentDidUpdate() {\n    if (this.props.start === true) {\n      this.start();\n      console.log('component did update!');\n\n    }\n  }\n\n  start = () => {\n    this.playerInterval = setInterval(() => {\n      this.updatePlayerPosition();\n    }, constants.INTERVAL);\n\n    // place fruit\n    const timeout = (Math.random() * 10000)\n    this.fruitTimeout = setTimeout(() => {\n      this.placeFruit()\n    }, timeout);\n  }\n\n  placeFruit = () => {\n    // place new fruit in random location--push to array\n    // Can't be in same location as other fruit or player\n    // buffer around player?\n    const self = this;\n\n    // loop through player locations and fruit and reassign if fruit top / left equal to these\n    const newFruit = this.checkOccupiedSquares();\n    const date = new Date()\n    newFruit.timeStamp = Date.UTC()\n    this.setState({\n      fruit: [...this.state.fruit, newFruit]\n    })\n\n    // fruit disappears after random seconds between 10 and 20 sec\n  }\n  checkOccupiedSquares = () => {\n    const top = constants.INDICES100[Math.floor(Math.random() * constants.INDICES100.length)]\n    const left = constants.INDICES100[Math.floor(Math.random() * constants.INDICES100.length)]\n    const occupiedSquares = [...this.state.playerState, ...this.state.fruit]\n    for (let i = 0; i < occupiedSquares.length; i++) {\n      const occupiedTop = occupiedSquares[i]\n      const occupiedLeft = occupiedSquares[i]\n      if (top === occupiedTop && left === occupiedLeft) return this.checkOccupiedSquares()\n    }\n    return { top: top, left: left }\n  }\n\n  updatePlayerPosition = () => {\n    let { playerSpeed } = this.state\n    // if player is turning, map playerState, checking each body piece and \n    // only updating if past the turning threshold.\n    let turning = false;\n\n    let playerState = [...this.state.playerState].map((piece, i) => {\n      if (piece.turning.length > 0) {\n        console.log('turning');\n\n        let { direction: currentDirection } = piece\n        const { threshold, direction: turningDirection } = piece.turning[0]\n        const { top, left } = piece\n        switch (currentDirection) {\n          case constants.UP:\n            // passed turning threshold?\n            //threshold = 0\n            // top = 10\n            // speed = 20\n            // next move top = -10\n            if (top - playerSpeed <= threshold) {\n              console.log('up');\n              // if threshold exceeded,\n              // reassign currentDirection\n              piece.direction = turningDirection\n              const overshotDistance = (threshold + playerSpeed) - top\n              // *** TO DO  ***\n              // write a function to update top/left with overshotDistance + or - left (switch depending on turning direction)\n              piece = this.movePlayer(piece, overshotDistance)\n              // make sure player is turning in the row or column coords by setting the head to the threshold\n              piece.top = threshold\n              piece.turning.shift()\n            } else {\n              piece = this.movePlayer(piece, playerSpeed)\n            }\n            break\n          case constants.RIGHT:\n            if (left >= threshold - playerSpeed) {\n              console.log('right');\n              piece.direction = turningDirection\n              const overshotDistance = left - (threshold - playerSpeed)\n              piece.left = threshold\n              piece = this.movePlayer(piece, overshotDistance)\n              piece.turning.shift()\n            } else {\n              piece = this.movePlayer(piece, playerSpeed)\n            }\n            break\n\n          case constants.DOWN:\n            if (top + playerSpeed >= threshold) {\n              console.log('down');\n\n              piece.direction = turningDirection\n              const overshotDistance = top - (threshold - playerSpeed)\n              piece.top = threshold;\n              piece = this.movePlayer(piece, overshotDistance)\n              piece.turning.shift()\n            } else {\n              piece = this.movePlayer(piece, playerSpeed)\n            }\n            break;\n          case constants.LEFT:\n            // left = 110\n            // threshold = 100\n            // next move left = 90\n            // is left - speed <= threshold\n            if (left - playerSpeed <= threshold) {\n              console.log('left');\n\n              piece.direction = turningDirection\n              const overshotDistance = (threshold + playerSpeed) - left\n              piece.left = threshold;\n              piece = this.movePlayer(piece, overshotDistance)\n              piece.turning.shift()\n            } else {\n              piece = this.movePlayer(piece, playerSpeed)\n            }\n            break;\n          default:\n            break\n        }\n      } else {\n        piece = this.movePlayer(piece, playerSpeed)\n      }\n      return piece\n    })\n    const updatedPlayerState = playerState.map((bodyPiece) => {\n      const { direction: playerDirection } = bodyPiece\n      // bodyPiece = this.movePlayer(bodyPiece, playerSpeed)\n      return bodyPiece\n    })\n    this.checkForFruit(playerState);\n    // Check if level is clear\n    if (this.state.fruitEatenThisLevel >= constants.NEXT_LEVEL_THRESHOLD) {\n      this.advanceLevel()\n    } else {\n      this.setState({\n        playerState: playerState\n      })\n    }\n  }\n\n  movePlayer = (bodyPiece, playerSpeed) => {\n    const { direction: playerDirection } = bodyPiece\n    const { top, left } = bodyPiece\n    // check walls\n    switch (playerDirection) {\n      case constants.UP:\n        // top - playerSpeed is where the player will be after moving\n        if (top - playerSpeed < 0) {\n          bodyPiece.top = 0;\n          this.endGame()\n          // exit function and don't move player\n          return bodyPiece\n        }\n        break\n      case constants.DOWN:\n        // - 100 because the position (top, left) is zero-indexed, but cell size is squares * 100\n        if (top + playerSpeed > constants.CELLSIZE100 - 100) {\n          bodyPiece.top = constants.CELLSIZE100 - 100;\n          this.endGame()\n          return bodyPiece\n        }\n        break\n      case constants.LEFT:\n        if (left - playerSpeed < 0) {\n          bodyPiece.left = 0;\n          this.endGame()\n          return bodyPiece\n        }\n        break\n      case constants.RIGHT:\n        if (left + playerSpeed > constants.CELLSIZE100 - 100) {\n          bodyPiece.left = constants.CELLSIZE100 - 100;\n          this.endGame()\n          return bodyPiece\n        }\n        break\n      default:\n        break\n    }\n\n    switch (playerDirection) {\n\n      case constants.UP:\n        // wait until next column.  Worm can only go in the columns/rows\n        bodyPiece.top -= playerSpeed\n        break\n      case constants.RIGHT:\n        bodyPiece.left += playerSpeed\n        break\n      case constants.DOWN:\n        bodyPiece.top += playerSpeed\n        break\n      case constants.LEFT:\n        bodyPiece.left -= playerSpeed\n        break\n      default:\n        break\n    }\n\n    return bodyPiece\n  }\n\n  advanceLevel = () => {\n    // check if enough fruit eaten to get to next level\n    // add body piece\n    let nextPlayerState = []\n    const { snakeLength, playerSpeed } = this.state\n\n    for (let i = 0; i <= this.state.snakeLength; i++) {\n      const bodyPiece = {\n        top: constants.INDICES100[0],\n        left: constants.INDICES100[i],\n        direction: constants.RIGHT,\n        bodyIndex: 2,\n        turning: []\n      }\n      // snake head = higher value of i, at position 0\n      nextPlayerState.unshift(bodyPiece)\n    }\n    this.pause()\n    this.setState({\n      playerState: nextPlayerState,\n      message: true,\n      paused: false,\n      snakeLength: snakeLength + 1,\n      playerSpeed: playerSpeed + 10,\n      fruitEatenThisLevel: 0,\n    })\n\n    this.showMessage(\"Ready, go!\", false);\n    setTimeout(() => {\n      this.clearMessage()\n      this.start()\n    }, 1000);\n  }\n\n  endGame = () => {\n    window.clearInterval(this.playerInterval)\n    window.clearTimeout(this.fruitTimeout)\n    this.showMessage(\"Game Over\", true)\n  }\n\n  checkForFruit = (playerState) => {\n    let scoreIncrease = 0\n    let updatedFruitEatenThisLevel = this.state.fruitEatenThisLevel\n    const updatedFruit = this.state.fruit.filter((fruitPiece, i) => {\n      const playerTop = Math.floor(playerState[0].top / 100)\n      const playerLeft = Math.floor(playerState[0].left / 100)\n      const fruitTop = fruitPiece.top / 100\n      const fruitLeft = fruitPiece.left / 100\n      if (playerTop === fruitTop &&\n        playerLeft === fruitLeft) {\n        // increment fruitEatenThisLevel\n        updatedFruitEatenThisLevel++\n        // place new fruit after random time 0-10 sec\n        const timeout = (Math.random() * 10000)\n        this.fruitTimeout = setTimeout(() => {\n          this.placeFruit()\n        }, timeout);\n        // ate fruit (fruit disappears)\n\n        return false\n      }\n      // didn't eat the fruit\n      return true\n    })\n    // update if fruit was eaten\n    if (updatedFruitEatenThisLevel > this.state.fruitEatenThisLevel) {\n      this.setState({\n        score: this.state.score + this.state.fruitValue,\n        fruit: updatedFruit,\n        fruitEatenThisLevel: updatedFruitEatenThisLevel,\n        fruitValue: this.state.fruitValue * 2,\n      })\n    }\n  }\n\n  handlePlayerMovement = (newDirection) => {\n    const { playerState } = this.state\n    const turnObjectInHeadBool = playerState[0].turning.length > 0\n    const updatedPlayerState = [...this.state.playerState].map((piece, i) => {\n      // player changed their mind, replace turn direction\n      if (turnObjectInHeadBool) {\n        piece.turning.pop()\n      }\n      // Add turn to the queue\n      const threshold = this.getTurnThreshold(playerState[0].direction, playerState[0])\n      const turning = [...piece.turning]\n      turning.push({\n        direction: newDirection,\n        threshold: threshold\n      })\n      piece.turning = turning\n\n      return piece\n    })\n    this.setState({\n      playerState: updatedPlayerState\n    })\n  }\n\n  getTurnThreshold = (playerDirection, playerPosition) => {\n    let threshold\n    switch (playerDirection) {\n      case constants.UP:\n        // looping from small to large values of y\n        // example:\n        // 247 - 47 = 200\n        threshold = (playerPosition.top - playerPosition.top % 100)\n        break;\n      case constants.DOWN:\n        threshold = (playerPosition.top - playerPosition.top % 100) + 100\n        break;\n      case constants.LEFT:\n        // highest x that is lower than position.left\n        // left = 110\n        // threshold = 100\n        threshold = (playerPosition.left - playerPosition.left % 100)\n        break;\n      case constants.RIGHT:\n        threshold = (playerPosition.left - playerPosition.left % 100) + 100\n        break;\n      default:\n        break;\n    }\n    return threshold\n  }\n\n  pause = () => {\n    if (this.state.paused === true) {\n      this.start()\n      this.setState({ paused: false })\n    } else {\n      window.clearInterval(this.playerInterval)\n      this.setState({ paused: true })\n    }\n  }\n\n  handleKeyDown = (e) => {\n\n    if (e.keyCode === 80) { // p\n      this.pause()\n    } else {\n\n      let newDirection;\n      switch (e.keyCode) {\n        case 37:\n          newDirection = constants.LEFT;\n          break;\n        case 38:\n          newDirection = constants.UP\n          break;\n        case 39:\n          newDirection = constants.RIGHT;\n          break;\n        case 40:\n          newDirection = constants.DOWN;\n          break;\n\n        default:\n          return;\n      }\n\n      const direction = this.state.playerState[0].direction\n      if (direction !== newDirection &&\n        constants.OPPOSITE_DIRECTIONS[direction] !== newDirection) {\n        this.handlePlayerMovement(newDirection)\n      }\n    }\n  }\n\n  showMessage = (message, playAgainButton) => {\n    this.setState({\n      message: message,\n      playAgainButton: playAgainButton\n    })\n  }\n\n  clearMessage = () => {\n    this.setState({\n      message: null,\n      playAgainButton: false,\n    })\n  }\n\n  playAgain = () => {\n    this.setState(getDefaultState(), () => {\n      this.start();\n    })\n  }\n\n  render() {\n    const snake = this.state.playerState.map((piece, i) =>\n      <SnakePiece\n        key={i.toString()}\n        top={piece.top}\n        left={piece.left}\n      />\n    )\n    const fruit = this.state.fruit.map((fruit, i) =>\n      <Fruit key={i.toString()}\n        top={fruit.top}\n        left={fruit.left}\n\n      />\n    )\n\n    return (\n      <div>\n        {this.state.message && (\n          <Message\n            message={this.state.message}\n            playAgainButton={this.state.playAgainButton}\n            playAgain={this.playAgain.bind(this)} />\n        )}\n\n        <div className=\"row\" style={row}>\n          <div className=\"board\" style={board}>\n            {snake}\n            {fruit}\n            <Board />\n          </div>\n          <div className=\"score\" style={score}>\n            <h2 style={scoreText}>\n              Score: {this.state.score}\n            </h2>\n\n            <div style={scoreRow}>\n              <RelativeSquare\n                backgroundColor={constants.GREEN}\n              />\n              <h2 style={fruitText}>\n                {this.state.fruitValue} {this.state.fruitValue > 1 ?\n                  <span>points</span>\n                  :\n                  <span>point</span>\n                }\n              </h2>\n            </div>\n          </div>\n        </div>\n      </div>\n    )\n  }\n}","import React, { Component } from 'react';\nimport './App.css';\n// import Game from './game'\nimport Game from './Containers/game'\n\nclass App extends Component {\n  constructor() {\n    super()\n\n  }\n \n  render() {\n    return (\n      <div className=\"App\" style={{ backgroundColor: 'black', height: '100vh' }}>\n        <h1 style={{ color: 'white', margin: '0' }}>Snake</h1>\n        <Game/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}